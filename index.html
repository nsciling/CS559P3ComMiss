<!DOCTYPE html>
<!-- saved from url=(0112)file:///C:/Users/nsciling/AppData/Local/Microsoft/Windows/INetCache/Content.Outlook/20NNIWZA/nss_JShomework.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
    <title>02-07-01</title>
    <style>
        canvas {
            border: 1px solid black;
        }
        svg {
            border: 1px solid black;
        }
    </style>
</head>
<body>
	<h1>Circles that Change on Mouse Events</h1>
	<ul>
		<li>Left click to create a circle. Right click will NOT create a new circle.</li>
		<li>Hover over the circle to change the color.</li>
		<li>Click inside the circle to change its default color, and give it a new hover color.</li>
		<li>If circles overlap, hovering and/or clicking on the overlapped portion will cause all circles underneath to change color.</li>
		<li>Note that after left-clicking to create a new circle, your cursor must leave the circle and re-enter to start the hover color changing behavior.</li>
	</ul>
    <canvas id="box1canvas" height="400" width="600"></canvas>
    <script type="module" defer="">
		// @ts-check
		export {};

		// Find the canvas and start!
		let canvas = /** @type {HTMLCanvasElement} */ (document.getElementById("box1canvas"));
		let context = canvas.getContext('2d');

		// Array to hold all circle objects
		let circleList = [];

		// Set the default circle radius & line width
		context.lineWidth = 2;
		let radius = 15;

		/**
		 * Event handler function to initiate drawing a circle
		 *  
		 * @param {object} event - the mouse action event
		 */
		canvas.onmousedown = function(event) {

			// filter out right-clicks
			if(isLeftClick(event)==0) return;

			mouseActionReceiver(event, 1);
		}

		/**
		 * Event handler function to initiate a hover change color
		 * 
		 * @param {object} event - the mouse action event
		 */
		canvas.onmousemove = function(event) {
			mouseActionReceiver(event, 0);
		}

		/**
		 * Function serving as main entry in mouse recoloring functions
		 * 
		 * @param {object} event - mouse event from caller
		 * @param {number} isClick - 1 if this is a click event,
		 *                           0 if a hover
		 *                           default is 0 if undefined
		 */
		function mouseActionReceiver(event, isClick) {
			// if isClick is undefined, default to hover
			if(isClick===undefined) isClick=0;

			// get the x & y information by relationship with
			// the bounding canvas
			let box = event.target.getBoundingClientRect();
			let x = event.clientX - box.left;
			let y = event.clientY - box.top;

			// see if we need to recolor circles
			let count = recolorCircles(x, y, isClick);

			// if is a click and we didn't recolor any circles,
			// we need to add a new circle
			if(isClick!=0 && count<1) {
				circleList.push({x:x, y:y, rad:radius, fillStyle:"green", 
					strokeStyle:"darkgreen", newCircle:1}); // flag circle as new to prevent immediate
															// hover recoloring
			}

			// update the canvas
			redrawCanvas();
		}


		/**
		 * A function that clears & redraws the entire canvas
		 */
		function redrawCanvas() {
			
			// clear the area
			context.clearRect(0, 0, 
				canvas.getAttribute("width").valueOf(), 
				canvas.getAttribute("height").valueOf());

			// draw all circles
			circleList.forEach((circle) => drawCircle(circle));
		}

		/**
		 * A function to draw, fill, and stroke a circle.
		 * This function expects the object to have the colors.
		 * 
		 * @param {object} circle - circle object to draw
		 */
		function drawCircle(circle) {
			context.fillStyle=circle.fillStyle;
			context.strokeStyle=circle.strokeStyle;
			context.beginPath();
			context.arc(circle.x, circle.y, circle.rad, 0, 2 * Math.PI);
			context.fill();
			context.stroke();
		}

		/**
		 * Function to recolor all the circles 
		 * 
		 * @param {number} curX - x coordinate of mouse
		 * @param {number} curY - y coordinate of mouse
		 * @param {number} isClick - non-zero if clicking; 0 if hovering
		 * 
		 * @returns the number of circles mouse X,Y coords are within
		 */
		function recolorCircles(curX, curY, isClick) {

			//if isClick is undefined, assume hover (aka not click)
			if(isClick===undefined) isClick=0;

			// instantiate return variable
			let ret=0;

			// loop through all the circles to recolor
			let i = 0
			while(i < circleList.length) {
				//get circle element
				let circle = circleList[i];
				if(distFromCenter(circle, curX, curY) <= circle.rad) {
					//update the count of circles within
					ret++;

					// if this is a click event, update the click colors
					// else, update the hover colors
					if(isClick!=0) setClickColors(circle);
					else setInsideHoverColors(circle);
				} 
				else {
					// if not inside circle, but the circle
					// evaluated is still flagged new, unflag it
					circle.newCircle=0;
					// ...and set the hover colors
					setOutsideHoverColors(circle);
				}
				// increment i
				i++;
			}

			return ret;
		}


		/**
		 * Calculates the distance from the current mouse coordinates
		 * to the center of a supplied circle object
		 * 
		 * @param {object} circle - a circle object with x, y, and rad elements
		 * @param {number} eventX - x position of mouse
		 * @param {number} eventY - y position of mouse
		 * @returns distance between mouse event and center of circle
		 */
		function distFromCenter(circle, eventX, eventY) {

			// if any values are undefined, return a large number
			if(circle===undefined) return 9999;
			if(eventX===undefined) return 9999;
			if(eventY===undefined) return 9999;
			
			// get hypotenuse to compare to circle radius
			let xDiff = (circle.x-eventX);
			let yDiff = (circle.y-eventY);
			
			return Math.sqrt(Math.pow(xDiff,2)+Math.pow(yDiff,2));
		}

		/**
		 * Checks if the click is a left-mouse click
		 * 
		 * Adapted from https://stackoverflow.com/questions/3944122/detect-left-mouse-button-press
		 * 
		 * @param {object} event - a mouse click event
		 * @returns 1 if is a left-click event, 0 otherwise
		 */
		function isLeftClick(event) {
			// check for undefined event
			if(event===undefined) return 0;

			// check if buttons not in event
			if("buttons" in event) return (event.buttons == 1);

			var button = (event.which || event.button);

			return (button == 1);
		}

		/**
		 * Provided a circle object, set its hover colors
		 * when outside of the circle's radius
		 * 
		 * @param {object} circle - object to recolor
		 */
		function setOutsideHoverColors(circle) {
			if(circle===undefined) return;
			
			// the only hover colors are yellow & blue
			if(circle.fillStyle=="yellow") {
				circle.fillStyle = "green";
				circle.strokeStyle = "darkgreen";
				return;
			} 
			
			if (circle.fillStyle=="blue") {
				circle.fillStyle = "orange";
				circle.strokeStyle = "red";
				return;
			}

		}

		/**
		 * Provided a circle object, set its hover colors
		 * when inside a circle's radius
		 * 
		 * @param {object} circle - object to recolor
		 */
		function setInsideHoverColors(circle) {
			if(circle===undefined) return;
			//if a new circle, don't perform hover behavior
			if(circle.newCircle==1) return;  

			// the only hover colors are yellow & blue
			if(circle.fillStyle=="green") {
				circle.fillStyle = "yellow";
				circle.strokeStyle = "goldenrod";
				return;
			} 
			
			if (circle.fillStyle=="orange") {
				circle.fillStyle = "blue";
				circle.strokeStyle = "purple";
				return;
			}

		}

		/**
		 * Provided a circle object, set its click colors
		 * 
		 * @param {object} circle - object to recolor
		 */
		function setClickColors(circle) {
			if(circle===undefined) return;
			
			// 4 click combinations:
			// (1) green -> orange
			if(circle.fillStyle=="green") {
				circle.fillStyle = "orange";
				circle.strokeStyle = "red";
				return;
			}
			// (2) orange -> back to green
			if (circle.fillStyle=="orange") {
				circle.fillStyle = "green";
				circle.strokeStyle = "darkgreen";
				return;
			} 
			// (3) yellow -> blue (if hovering)
			if (circle.fillStyle=="yellow") {
				circle.fillStyle = "blue";
				circle.strokeStyle = "purple"
				return;
			} 
			// (4) blue -> back to yellow (again if hovering)
			if (circle.fillStyle=="blue") {
				circle.fillStyle = "yellow";
				circle.strokeStyle = "goldenrod";
				return;
			} 
			
		}
	
	</script>
	<br><button onclick="window.location.reload();">Refresh Page</button>
	<h1>Fireworks</h1>
	<ul>
		<li>Left or right click to create a new firework.</li>
		<li>Random fireworks will also appear.</li>
	</ul>
	<canvas id="box2canvas" height="400" width="600"></canvas>
	<script type="module" defer="">
	// @ts-check

	// Find the canvas and start!
	let canvas = document.getElementById("box2canvas");
	let context = canvas.getContext("2d");

	//this is a 'display list' -> list of objects we plan to draw
	let newColor = getRGBcolorString();
	let fwList = [{n:25, x: 250, y: 400, vx: 0, vy: -2, tx: 300, ty: 150, ay: 0.005, curColor: newColor, origColor: newColor}]
	let expList = [];   // explosions
	let expCount = 35;  // default number of explosions to produce

	canvas.onmousedown = function(event) {
		let box = event.target.getBoundingClientRect();
		let tx = event.clientX - box.left;  // target X coord for firework
		let ty = event.clientY - box.top;   // target Y coord for firework
		
		newColor = getRGBcolorString();

		fwList.push({n: expCount, x: tx, y: 400, vx: 0, vy: -(Math.random() * 6 + 2), tx: tx, ty: ty, ay: 0.005, curColor: newColor, origColor: newColor});
	}

	/**
	 * A function to draw a display list representing a firework.
	 */
	let draw = function() {
		//reset the canvas
		context.clearRect(0, 0, canvas.getAttribute("width"), canvas.getAttribute("height"))
		context.fillStyle = "#cffffa";
		context.fillRect(0,0,600,400);

		//check to add random fireworks
		if(Math.random() > 0.99) { launchRandomFirework(); }
		
		// Update the list
		for(let li of fwList) {
			li.x += li.vx;

			//make y decelerate as it nears the target
			if((li.y - li.ty) < 75) li.vy += li.ay;
			if((li.y - li.ty) > 0) li.y += li.vy;

			//make an explosion
			if (li.y <= li.ty && li.n > 0) {
				//once firework reaches target y value, hide it by making it the same
				//color as the canvas, with slight delay
				if (li.n < expCount) { li.curColor = context.fillStyle; };
				
				//decrease the explosion count, and push another explosion element
				li.n--;
				expList.push({x: li.x, y: li.y, vx: 4 * (Math.random() * 2 - 1),
					vy: 4 * (Math.random() * 2 - 1), ay: 0.04, color: li.origColor});
			}

			//remove the element if it is done exploding
			if(li.n <= 0) {
				let index = fwList.indexOf(li);
				fwList.splice(index,1);
			} else {
				//animate
				drawFirework(li.x, li.y, 5, li.curColor);
			}
		}

		// animate the explosion
		for(let an of expList) {
			an.x += an.vx;  // update x position of explosion
			an.vy += an.ay; // update y velocity (so that it speeds up towards ground)
			an.y += an.vy;  // update y position

			//remove the element if outside canvas bounds
			if(outsideBounds(an)) {
				let index = expList.indexOf(an);
				expList.splice(index,1);
			} else {
				an.color = fadeColor(an.color); // make the explosion more transparent
				drawExplosion(an.x, an.y, 4, an.color);
			}
		}

		// next frame
		window.requestAnimationFrame(draw);
	}

	/**
	 * Function to launch a random firework
	 */
	function launchRandomFirework() {
		newColor = getRGBcolorString();

		let x = getRandomBetween(0.1,0.9) * canvas.getAttribute("width"); // don't fire at the screen edges
		let y = getRandomBetween(0,0.95) * canvas.getAttribute("height"); // on't fire all the way to the top

		fwList.push({n:expCount, x: x, y: 400, vx: 0, vy: -(Math.random() * 5 + 1), 
			tx: 300, ty: y, ay: 0.005, curColor: newColor, origColor: newColor});
	}

	/**
	 * Function to get a random number between 2 numbers
	 * 
	 * @param {number} min - minimum limit
	 * @param {number} max - maximum limit
	 * @returns a number, or undefined if error
	 */
	function getRandomBetween(min, max) {
		if(max===undefined || min===undefined || max < min) return undefined;
		return ((Math.random() * (max - min)) + min);
	}

	/**
	 * Function to draw a firework circle
	 * 
	 * @param {number} x - x-coordinate of the circle in the frame
	 * @param {number} y - y-coordinate of the circle in the frame
	 * @param {number} rad - radius of the circle6
	 * @param {string} color - color of the circle
	 * @returns none; draws a circle on the webpage
	 */
	function drawFirework(x, y, rad, color) {
		//if we don't have the necessary data, quit
		if(x===undefined || y===undefined || rad===undefined || color===undefined) return;
		
		//save off context before 
		context.save();

		//draw firework
		context.beginPath();
		context.arc(x, y, rad, 0, 2 * Math.PI, false);
		context.fillStyle=color;
		context.fill();

		//restore context
		context.restore();
	}

	/**
	 * Function to draw an explosion square
	 * 
	 * @param {number} x - x-coordinate of the explosion particle
	 * @param {number} y - y-coordinate of the explosion particle
	 * @param {number} lw - the length(width) of the explosion particle
	 * @param {string} color - color of the particle
	 * @returns none; draws a square particle on the webpage
	 */
	function drawExplosion(x, y, lw, color) {
		//quit without necessary data
		if(x===undefined || y===undefined || lw===undefined || color===undefined) return;
		
		//save off context before 
		context.save();

		//draw explosion
		context.fillStyle = color;
		context.fillRect(x - Math.floor(lw/2), y - Math.floor(lw/2), lw, lw);

		//restore context
		context.restore();
	}

	/**
	 * Function to return a random RGB color string
	 * @returns string with RGB css format, ex: "rgb(100,200,100)"
	 */
	function getRGBcolorString() {
		let red = Math.floor(Math.random() * 255);
		let green = Math.floor(Math.random() * 255);
		let blue = Math.floor(Math.random() * 255);
		
		return "rgba(" + red + "," + green + "," + blue + ",1.0)";    
	}

	/**
	 * Function to transparent-ify the RGBA color string received
	 * 
	 * @param {string} colorString - an RGBA color string to edit
	 * @returns an updated color string with a lower transparency value,
	 *  or the original color string if no transparency value is found
	 */
	function fadeColor(colorString) {
		//console.log("Color: "+colorString);  // for testing

		// match on a regex for the transparency value
		const regex = /\,(\d\.\d+)\)/;
		let match=regex.exec(colorString)[1];

		if(match===undefined || match==null) return colorString;

		// reduce the transparency by 0.985x, rounded to 3 decimals
		let reduce = Math.round(match.valueOf()*0.985*1000)/1000

		//console.log("Replace: "+colorString.replace(regex,","+reduce+")")) // for testing
		return colorString.replace(regex,","+reduce+")");
	}

	/**
	 * 
	 * @param {*} element - an element with an x & y attribute; expected from the 'fwList' or 'expList' arrays
	 * @returns 1 if oustide canvas bounds, 0 otherwise
	 */
	 function outsideBounds(element) {

		if(element===undefined || element===null) return 0;

		// check if element is outside canvas bounds
		if(element.x < 0 || element.x > canvas.getAttribute("width")) return 1;
		if(element.y < 0 || element.y > canvas.getAttribute("height")) return 1;
		
		//default
		return 0;

	}


	window.requestAnimationFrame(draw); // start animation
	</script>
	<br><button onclick="window.location.reload();">Refresh Page</button>
    


</body></html>